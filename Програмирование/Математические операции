                                                    Математические операции     
Математика
 Простые действия:
  = присваивание
  + сложение
  - вычитание
  * умножение
  / деление
  % остаток от деления

Существуют также составные операторы, укорачивающие запись:
+= составное сложение: a += 10 равносильно a = a + 10
-= составное вычитание: a -= 10 равносильно a = a - 10
*= составное умножение: a *= 10 равносильно a = a * 10
/= составное деление: a /= 10 равносильно a = a / 10
%= остаток от деления: a %= 10 равносильно a = a % 10

Очень часто в программировании используется прибавление или вычитание единицы, для чего тоже есть короткая запись:
++ (плюс плюс) инкремент: a++ равносильно a = a + 1
-- (минус минус) декремент: a-- равносильно a = a - 1
Порядок записи инкремента играет очень большую роль: пост-инкремент var++ возвращает значение переменной до выполнения инкремента.
Операция пре-инкремента ++var возвращает значение уже изменённой переменной.
                                                Порядок вычислений
Порядок вычисления выражений подчиняется обычным математическим правилам: сначала выполняются действия в скобках, затем умножение и деление, и в конце - сложение и вычитание.
                                                Скорость вычислений
атематические вычисления выполняются процессором некоторое время, оно зависит от типа данных и типа операции. Вот время выполнения (в микросекундах) не оптимизированных компилятором вычислений для Arduino Nano 16 МГц:

                   Время выполнения, мкс
Тип данных
           Сложение и вычитание 	  Умножение	      Деление, остаток
int8_t	         0.44	               0.625	              14.25
uint8_t	         0.44	               0.625	               5.38
int16_t	         0.89	               1.375	              14.25
uint16_t	       0.89	               1.375	              13.12
int32_t	         1.75	               6.06	                 38.3
uint32_t	       1.75	               6.06	                 37.5
float	          8.125	                10	                 31.5

Нужно понимать, что не все во всех случаях математические операции занимают ровно столько времени, так как компилятор их оптимизирует.
Можно помочь ему в этом, подробнее читайте в уроке по оптимизации кода.
Операции с float выполняются гораздо дольше целочисленных, потому что в AVR нет аппаратной поддержки чисел с плавающей точкой и она реализована программно как сложная библиотека. 
В некоторых микроконтроллерах есть FPU - специальный аппаратный блок для вычислений с float.
                                                Целочисленное деление
При целочисленном делении результат не округляется по "математическим" правилам, дробная часть просто отсекается, фактически это округление вниз: и 9/10 и 1/10 дадут 0.
При использовании float само собой получится 0.9 и 0.1. Если нужно целочисленное деление с округлением вверх, его можно реализовать так: вместо x / y записать (x + y - 1) / y. 
Рассмотренные выше примеры деления на 10 дадут результат 1.
Для округления по обычным математическим правилам можно использовать функцию round(), но она довольно тяжёлая, так работает с float.
Операции целочисленного деления на AVR выполняются дольше по той же причине - они реализованы программно, а вот умножение и сложение с вычитанием МК делает аппаратно и очень быстро.
                                                Переполнение переменной
Вспомним предыдущий урок о типах данных: что будет с переменной, если её значение выйдет из допустимого диапазона? 
Тут всё весьма просто: при переполнении в большую сторону из нового значения вычитается максимальное значение переменной, и у неё остаётся только остаток.
Для сравнения представим переменную как ведро. Будем считать, что при наливании воды и заполнении ведра мы скажем стоп, выльем из него всю воду, а затем дольём остаток. 
Вот так и с переменной, что останется - то останется. Если переполнение будет несколько раз - несколько раз опорожним наше "ведро" и всё равно оставим остаток. Ещё один хороший пример - кружка Пифагора.
При переполнении в обратную сторону (выливаем воду из ведра), будем считать, что ведро полностью заполнилось. Да, именно так =)
                                                 Особенность больших вычислений
Для сложения и вычитания по умолчанию используется ячейка 4 байта (long), но для умножения и деления - 2 байта (int). 
Если при умножении или делении в текущем действии результат превысит 32768 - ячейка переполнится и мы получим некорректный результат.
Для исправления ситуации нужно привести тип переменной к long перед вычислением, что заставит МК выделить дополнительную память. 
Например  a = (long)b * c;
Для цифр существуют модификаторы, делающие то же самое:

U или u - перевод в uint16_t (от 0 до 65'535). Пример: 36000u
L или l - перевод в int32_t (-2 147 483 648… 2 147 483 647). Пример: 325646L
UL или ul - перевод в uint32_t (от 0 до 4 294 967 295). Пример: 361341ul
                                               
                                               Особенности float
Помимо медленных вычислений, поддержка работы с float занимает много памяти, т.к. реализована в виде "библиотеки".
Использование математических операций с float однократно добавляет примерно 1.5 кБ в память программы.
С вычислениями есть такая особенность: если в выражении нет float чисел, то вычисления будут иметь целый результат (дробная часть отсекается). 
Для получения правильного результата нужно писать преобразование (float) перед действием, использовать float числа или float переменные. 

При присваивании float числа целочисленному типу данных дробная часть отсекается. Если хотите математическое округление - его нужно использовать отдельно
Также есть модификатор f, который можно применять только к цифрам float. Смысла в нём нет, но такую запись можно встретить.

Следующий важный момент: из за особенности самой модели "чисел с плавающей точкой" - вычисления иногда производятся с небольшой погрешностью. Смотрите (значения выведены через порт)
Казалось бы, val2 должна стать ровно 0.1 после вычитания, но в 8-ом знаке вылезла погрешность! Будьте очень внимательны при сравнении float чисел, особенно со строгими операциями <=: результат может быть некорректным и нелогичным.
